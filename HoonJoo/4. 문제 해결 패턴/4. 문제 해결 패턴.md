# 4. 문제 해결 패턴

생성일: 2021년 12월 18일 오전 1:22

> 이번 챕터에서는 일반적인 문제풀이 패턴에 대해서 학습한다.

---

### 1️⃣  빈도수 세기 패턴

> 🎯 2중으로 중첩된 반복문 보다는, 단일 반복문 두 개를 사용하는 것이 훨씬 좋다.

1. **빈도수 세기 알고리즘 패턴 (전체 코드)**

   ```jsx
   function same(arr1, arr2) {
     if (arr1.length !== arr2.length) {
       return false;
     }
     let frequencyCounter1 = {};
     let frequencyCounter2 = {};
     for (let val of arr1) {
       frequencyCounter1[val] = (frequencyCounter1[val] || 0) + 1;
     }
     for (let val of arr2) {
       frequencyCounter2[val] = (frequencyCounter2[val] || 0) + 1;
     }
     console.log(frequencyCounter1);
     console.log(frequencyCounter2);
     for (let key in frequencyCounter1) {
       if (!(key ** 2 in frequencyCounter2)) {
         return false;
       }
       if (frequencyCounter2[key ** 2] !== frequencyCounter1[key]) {
         return false;
       }
     }
     return true;
   }

   same([1, 2, 3, 2, 5], [9, 1, 4, 4, 11]);
   ```

2. 패턴 분석 (단계별)

   - 두 배열의 길이 비교
     > 만약 두 배열의 길이가 다르다면? → 중복된 값이 있거나, 생략된 값이 있는 것을 의미한다.
     ```jsx
     // 두 배열의 길이가 같지 않다면, false를 반환하고 함수를 종료한다.
     if (arr1.length !== arr2.length) {
       return false;
     }
     ```
   - 객체 생성

     > for문을 활용하여 대상객체와 도구객체 하나씩을 만든다.  
     >  "**_그리고 위에서도 설명했듯, 중첩 반복문 보다는 단일 반복문 여러개가 더 낫다."_**
     > <img src="https://user-images.githubusercontent.com/67448481/146584026-a4be474c-dd71-4e6c-b528-bf42e25cf062.png" alt="val" width="300">

     ```jsx
     let frequencyCounter1 = {};
     let frequencyCounter2 = {};
     for (let val of arr1) {
       // 아래의 코드는 이러한 결과를 도출한다 => { val : (val or 0) + 1 }
       // 즉, 해당 값이 존재하면 그 값 +1을 해주고, 없으면 0+1을 해준다.
       frequencyCounter1[val] = (frequencyCounter1[val] || 0) + 1;
     }
     for (let val of arr2) {
       frequencyCounter2[val] = (frequencyCounter2[val] || 0) + 1;
     }

     // 이렇게 하면, 두 개의 도구대상 객체가 생성된다.
     ```

   - 반복문 내에서 도구/대상 비교하기
     > 객체에 대한 반복문에서는 반환값이 value가 아닌, **key가 반환된다.**
     ```jsx
     for (let key in frequencyCounter1) {
       // {key:1} -> {key^2:1}의 구조에서,
       // key^2의 값이 fC2의 키값에 존재하는지 체크하는 조건문
       if (!(key ** 2 in frequencyCounter2)) {
         return false;
       }
       // {key^2 : n}에서 n값이 fC1의 {key: n}에서의 n값과 같은지 같지 않은지 체크
       if (frequencyCounter2[key ** 2] !== frequencyCounter1[key]) {
         return false;
       }
     }
     // 이 모든 조건문을 통과하면 => true를 리턴한다.
     ```

3. `for ... in` 과 `for ... of`의 차이?

   - `for ... in` : 객체에서도 사용 가능하다.
   - `for ... of` : 객체에서 사용 불가능하다 (문자열, 배열, Set 등등)

4. ✏️  **예제 : (애너그램 함수)**

   > 위의 빈도수 체크 알고리즘을 활용해 두 문자열을 비교하는 함수를 만들어보자. (소문자만 고려)

   1. 객체 만들기

      <img src="https://user-images.githubusercontent.com/67448481/146649101-0525125c-cdd8-477d-b959-b56d59b86640.png" alt="obj"/>

      ```jsx
      function validAnagram(a, b) {
        if (a.length !== b.length) {
          return false;
        }
        let aObj = {};
        let bObj = {};
        for (let val of a) {
          aObj[val] = (aObj[val] || 0) + 1;
        }
        for (let val of b) {
          bObj[val] = (bObj[val] || 0) + 1;
        }
        console.log(aObj, bObj);
      }
      ```

   2. 객체의 key와 value 일치여부 각각 체크하기

      ```jsx
      for (let key in aObj) {
        if (!(key in bObj)) {
          return false;
        }
        if (aObj[key] !== bObj[key]) {
          return false;
        }
      }
      ```

   3. 💡 최종 솔루션 (1)

      ```jsx
      function validAnagram(a, b) {
        if (a.length !== b.length) {
          return false;
        }
        let aObj = {};
        let bObj = {};
        for (let val of a) {
          aObj[val] = (aObj[val] || 0) + 1;
        }
        for (let val of b) {
          bObj[val] = (bObj[val] || 0) + 1;
        }
        for (let key in aObj) {
          if (!(key in bObj)) {
            return false;
          }
          if (aObj[key] !== bObj[key]) {
            return false;
          }
        }
        return true;
      }
      ```

   4. 💡 이외의 솔루션 (2)

      ```jsx
      function validAnagram(first, second) {
        if (first.length !== second.length) {
          return false;
        }

        const lookup = {};

        for (let i = 0; i < first.length; i++) {
          let letter = first[i];
          lookup[letter] ? (lookup[letter] += 1) : (lookup[letter] = 1);
        }

        for (let i = 0; i < second.length; i++) {
          let letter = second[i];
          // 만약 a를 예로 들면, {a : 0}이어도, 객체에선 이를 존재하지 않는다고 계산한다.
          if (!lookup[letter]) {
            return false;
          } else {
            lookup[letter] -= 1;
          }
          // value가 0이면 false로 인식하기 때문에, 굳이 마지막에 모든 key의 value들이 0인지 더블체킹 할 필요는 없다.
        }
        return true;
      }
      ```

---

### 2️⃣  다중 포인터 패턴
